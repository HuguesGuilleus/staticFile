// Copyright (c) 2020, Hugues GUILLEUS <ghugues@netc.fr>. All rights reserved.
// Use of this source code is governed by a BSD
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"github.com/HuguesGuilleus/static.v2"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

var dev = false

func main() {
	outFile := flag.String("out.file", "assets.go", "The output go source file.")
	outPkg := flag.String("out.pkg", "main", "The package of the source file.")
	flag.BoolVar(&dev, "dev", false, "dev mode, the file are read for each call.")
	flag.Parse()

	os.MkdirAll(filepath.Dir(*outFile), 0775)

	out, err := os.OpenFile(*outFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0664)
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()

	fmt.Fprintln(out, "// Code generated by staticFile; DO NOT EDIT.")
	fmt.Fprintf(out, "// source files: %q\n", flag.Args())
	fmt.Fprintln(out, "// dev mode:", dev)

	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "package", *outPkg)
	fmt.Fprintln(out, "")

	if dev {
		fmt.Fprintln(out, devImports)
		for _, f := range flag.Args() {
			n, f := getName(f)
			fmt.Fprintf(out, "func %s() []byte {\n\troot := %q\n\t%s\n}\n\n", n, f, devReader)
		}
	} else {
		for _, f := range flag.Args() {
			n, f := getName(f)
			log.Println("--", n)
			fmt.Fprintf(out, "func %s() []byte { return []byte(%s) }\n\n", n, readFiles(f))
		}
	}
}

// Return the files strources and the name of the future function.
func getName(f string) (string, string) {
	if !strings.Contains(f, "=") {
		return fname(f), f
	}
	s := strings.SplitN(f, "=", 2)
	if s[0] == "" || s[1] == "" {
		log.Fatal("Need funcName=path or just path")
	}
	return s[0], s[1]
}

// Transform the file name to the function name associed.
func fname(f string) string {
	f = strings.TrimSuffix(f, filepath.Ext(f))
	f = strings.TrimRight(f, string(os.PathSeparator))

	split := strings.FieldsFunc(f, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsNumber(r)
	})
	for i := range split {
		split[i] = firstUpper(split[i])
	}
	return strings.Join(split, "")
}

// Transform the first rune to upper case.
func firstUpper(s string) string {
	if s == "" {
		return ""
	}
	r, size := utf8.DecodeRuneInString(s)
	return string(unicode.ToUpper(r)) + s[size:]
}

// read files, minify the contents and return it quoted
func readFiles(root string) string {
	data := make([]byte, 0)
	filepath.Walk(root, func(f string, info os.FileInfo, err error) error {
		if err != nil {
			log.Fatalf("Error when read %q: %v", f, err)
		}
		if info.IsDir() {
			return nil
		}

		log.Println("  ", f)

		d, err := ioutil.ReadFile(f)
		if err != nil {
			log.Fatalf("Error when read %q: %v", f, err)
		}
		data = append(data, getMinify(f)(d)...)

		return nil
	})
	return strconv.Quote(string(data))
}

// Return a minify according to the file name. The minifier is never nil.
func getMinify(f string) static.Minifier {
	switch filepath.Ext(f) {
	case ".css":
		return static.CssMinify
	case ".html", ".gohtml":
		return static.HtmlMinify
	case ".js":
		return static.JsMinify
	}
	return func(in []byte) []byte { return in }
}

const devReader = `data := make([]byte, 0)
	filepath.Walk(root, func(f string, info os.FileInfo, err error) error {
		if err != nil {
			log.Fatalf("Error when read %q: %v", f, err)
		}
		if info.IsDir() {
			return nil
		}

		d, err := ioutil.ReadFile(f)
		if err != nil {

		}
		data = append(data, d...)

		return nil
	})
	return data`

const devImports = `import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)
`
